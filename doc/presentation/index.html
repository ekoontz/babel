<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=1024" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <title>babel</title>
    
    <meta name="description" content="A Clojure library for generation and parsing of natural language expressions." />
    <meta name="author" content="Eugene Koontz" />
    <meta name="thanks-to" content="http://impress.github.io/impress.js/ by @bartaz" />
    <link href="http://fonts.googleapis.com/css?family=Open+Sans:regular,semibold,italic,italicsemibold|PT+Sans:400,700,400italic,700italic|PT+Serif:400,700,400italic,700italic" rel="stylesheet" />

    <link href="css/impress-demo.css" rel="stylesheet" />
    <link href="css/dagre.css" rel="stylesheet" />
    
    <link rel="shortcut icon" href="favicon.png" />
    <link rel="apple-touch-icon" href="apple-touch-icon.png" />

    <link href="css/babel.css" rel="stylesheet" />
    <link href="css/graphs.css" rel="stylesheet" />

  </head>

<body class="impress-not-supported">

  <div id="prose-version" style="display:none">
    <p>
      Here are some random Engilsh expressions that babel can generate:

      her black bird's first shoe used to have Antonia
      you all would prepare yourselves
      the small pupil's professor's tall woman would move her

      babel.test.en> (repeatedly #(println (morph (generate))))
    </p>
    <p>
      How does it work?

      Definitions: 

      - phrase structure rule NP -> Det N
      - lexeme (a.k.a. terminal symbol) pizza

      A _phrase structure rule_ consists of a parent and two
      children, whereas a _lexeme_ has no children. The two children of a
      phrase structure rule may be either lexemes or other phrase
      structure rules.

      Babel creates an expression by adding children to rules until
      there are no more empty places in the tree to add children.

      But how does babel know:

      - which rule to start with?
      - which chidren may be added at which location, to which
      parents?
      - how to prevent the procedure from running forever?

      The solution is that both rules and lexemes are maps whose
      values are defined such that they are only allowed them to be
      combined in certain ways.

    </p>
    <p>

      Example 1: category (:cat)

      Lexemes are declared to have a :cat value which can only be one
      of a small number of possibilities: {:noun, :verb, :preposition,
      ..}. These are called "parts of speech". The phrase structure
      rules are declared to only allow children with a certain value.
      For example, the rule: NP -> Det N, the first child must be:
      {:cat :determiner}, while the second child must be: {:cat
      :noun}.
    </p>
    <p>

      In addition, the parent of the rule, also has a :cat value,
      which is the same as one of the children. For example, in the
      rule: NP -> Det N, the :cat of the entire rule is the same as
      that of the second child. This allows rules to be added to other
      rules only in a certain way. For example, in the rule: S -> NP
      VP, the first child must be {:cat :noun}, and the NP in turn,
      will be formed such that its second child is also {:cat :noun}.

    </p>
    <p>

      We call the child that shares the same :cat value as its parent,
      the _head_ child ,and the other child, we call the _complement_.
      (generate) builds a tree by adding _head_ children first, and
      then complements. This is to allow generation by a given
      specification to be efficient.
      
    </p>


    
    <p>

      Example 2: subcategorization (:subcat)
    </p>
    <p>

      The other way that we constrain the generation process is with
      another specially-designated key called :subcat. This key allows
      children to specify what their complement sibling will
      be. (Human children are not so fortunate - imagine if, as an
      older sibling, you could choose a sibling to your preferences.)
    </p>
    <p>

      For example, in the rule NP -> Det N, the head noun chooses a
      determiner according to whether the N is singular, mass, etc:
    </p>
    <p>

      A cat.
      Some cats.
      Some dirt.
      
      * A cats.
      * A dirt.
    </p>
    <p>

      Example 3: semantics: composition of expressions

      The semantics of a parent is a map nested within the parent's
      map, in the :sem key. This key's value is shared with the the
      :sem key's value in the head child.

    </p>
    <p>
      Example 4: semantics: selection of arguments
      
      heads of phrases constrain what their complement sibling will be
      by semantics as well as (as we saw in example 2) by category.

    </p>
      
    <p>
      Generation via specification.

      Earlier we saw a demonstration of random generation, but Babel
      can also generate expressions which match a desired
      specification. A specification is written as a Clojure map, just
      as phrase structure rules and lexemes are, e.g. :sem = :cat.

      babel.test.en> (repeatedly #(println (morph (generate {:synsem {:sem {:pred :cat}
                                                                      :cat :noun}}))))
some stupid student's old cat
Luisa's first cat
some old mothers' first mothers' red cats
      
    </p>

    <p>
      The generative process chooses rules and children randomly, but,
      when it adds children, it requires that the resulting structure
      conforms to the given specification.

      Show diagram showing rules and children are "belt fed" as children.
      
    </p>
    
    <p>
    This can be made reasonably efficent because of the constraints
    that the head and parent of a phrase structure rule share semantics and category.
    </p>

    <p>Unification: why it's important. Unification allows us to
    express grammatical information in a concise "Don't Repeat
    Yourself" manner. We can have relatively few rule, because the
    lexicon bears most of the responsibility for determining how
    expressions are generated.
    </p>
    <p>
      But: generation is still slow: we have to do a "sequential scan"
      of the potential children to find a child that actually matches
      our desired specification. Solution: add indices.
    </p>
    
  </div>
  
<!--
    For example this fallback message is only visible when there is `impress-not-supported` class on body.
-->
<div class="fallback-message">
    <p>Your browser <b>doesn't support the features required</b> by impress.js, so you are presented with a simplified version of this presentation.</p>
    <p>For the best experience please use the latest <b>Chrome</b>, <b>Safari</b> or <b>Firefox</b> browser.</p>
</div>

<div id="impress">

    <!--
        
        Here is where interesting thing start to happen.
        
        Each step of the presentation should be an element inside the `#impress` with a class name
        of `step`. These step elements are positioned, rotated and scaled by impress.js, and
        the 'camera' shows them on each step of the presentation.
        
        Positioning information is passed through data attributes.
        
        In the example below we only specify x and y position of the step element with `data-x="-1000"`
        and `data-y="-1500"` attributes. This means that **the center** of the element (yes, the center)
        will be positioned in point x = -1000px and y = -1500px of the presentation 'canvas'.
        
        It will not be rotated or scaled.
        
    -->

    <!--
        
        So to summarize of all the possible attributes used to position presentation steps, we have:
        
        * `data-x`, `data-y`, `data-z` - they define the position of **the center** of step element on
            the canvas in pixels; their default value is 0;
        * `data-rotate-x`, `data-rotate-y`, 'data-rotate-z`, `data-rotate` - they define the rotation of
            the element around given axis in degrees; their default value is 0; `data-rotate` and `data-rotate-z`
            are exactly the same;
        * `data-scale` - defines the scale of step element; default value is 1
        
        These values are used by impress.js in CSS transformation functions, so for more information consult
        CSS transfrom docs: https://developer.mozilla.org/en/CSS/transform
        
    -->

    <div class="step slide" data-x="-3000" data-y="-1500" data-scale="2">
      Babel
    </div>

    <div class="step slide" data-x="-1000" data-y="-1500" data-scale="2">
      Usage

      <div class="code">(require 'babel.english :as en)
(require 'babel.english)
(babel.english/generate)
(babel.english/generate-all)
      </div>

    </div>

    <div class="step slide"  data-x="1000" data-y="-1500" data-scale="2">
      how does it work?
      <div class="code">
	(defn generate-all [grammar lexicon & [trees]]
	  (let [tree (or trees grammar)]
	    (mapcat (fn [tree]
...
              (map (fn [child]
..
	   (over 
      </div>

    </div>

    <div class="step slide"  data-x="3000" data-y="-1500" data-scale="2">
       But this does not suffice:
       <ul>
	 <li>word order</li>
	 <li>agreement</li>
	 <li>semantic compositionality</li>
       </ul>

       We need some way for the nodes in the tree to <i>relate</i> to one another

    </div>

    <div class="step slide"  data-x="-3000" data-y="0" data-scale="2">
      Depth-first search (1): descend f() 
      <svg id="depth_first_1" width="600" height="600"><g/></svg>
    </div>

    <div class="step slide"  data-x="-1000" data-y="0" data-scale="2">
      Depth-first search (2): descend f() 
      <svg id="depth_first_2" width="600" height="600"><g/></svg>
    </div>

    <div class="step slide"  data-x="1000" data-y="0" data-scale="2">
      Depth-first search (3): descend f() 
      <svg id="depth_first_3" width="600" height="600"><g/></svg>
    </div>

    <div class="step slide"  data-x="3000" data-y="0" data-scale="2">
      Depth-first search (4): descend f() 
      <svg id="depth_first_4" width="600" height="600"><g/></svg>
    </div>

    <div class="step slide"  data-x="5000" data-y="0" data-scale="2">
      Depth-first search (5): descend f() 
      <svg id="depth_first_5" width="600" height="600"><g/></svg>
    </div>

    <div class="step slide"  data-x="7000" data-y="0" data-scale="2">
      Depth-first search (6): descend f() 
      <svg id="depth_first_6" width="600" height="600"><g/></svg>
    </div>

    <div class="step slide"  data-x="9000" data-y="0" data-scale="2">
      Depth-first search (7): descend f() 
      <svg id="depth_first_7" width="600" height="600"><g/></svg>
    </div>

    <div class="step slide"  data-x="11000" data-y="0" data-scale="2">
      Depth-first search (8): descend f() 
      <svg id="depth_first_8" width="600" height="600"><g/></svg>
    </div>

    <div id="transition0" class="step slide"  data-x="-3000" data-y="1500" data-scale="2">
      Depth-first search (final)
      <div style="float:right;width:50%;overflow:hidden;position:absolute;right:0;top:0;font-size:100%;">
        <div class="code">(generate {:sem _ (_,_)})</div>
        <div class="code">(generate {:sem ‍👁 (_,_)})</div>
	<div class="code">(generate {:sem ‍👁 (_, 🐱)})</div>
	<div class="code">(generate {:sem ‍👁 (‍👱‍♀️,_)})</div>
	<div class="code">(generate {:sem ‍👁 (‍👱‍♀️, 🐱})</div>
      </div>
      <div style="float:left;width:69%;height:600px;width:600px;position:absolute;left:1%;top:15%;font-size:100%">
	<svg id="she_sees_the_cat" width="600" height="600"><g/></svg>
      </div>
    </div>

    <div class="step" data-x="-3500" data-y="1800" data-scale="1">
      <!-- zoom in on previous slide. -->
    </div>
    
    <div class="step slide" data-x="-1000" data-y="1500" data-scale="2">
      <div class="avm">
	<table>
	  <tr>
	    <th>:foo</th>
	    <td>
	      <table
		 <tr>
		   <th>:bar</th>
		   <td class="ref"><div>1</div></td>
		   <td>42</td>
		 </tr>
		 <tr>
		   <th>:baz</th>
		   <td class="ref"><div>1</div></td>
		   <td>42</td>
		 </tr>
 	       </table>
	    </td>
          </tr>
        </table>
      </div>
    </div>

    <div class="step slide" data-x="-3000" data-y="3000" data-scale="2">
      Unification
    </div>

    <div class="step slide" data-x="-1000" data-y="3000" data-scale="2">
      Lexicon compilation

      <ul>
	 <li>defaults</li>
      </ul>

    </div>

    <div class="step slide" data-x="1000" data-y="3000" data-scale="2">
      over(parent,head) is function instantiation
    </div>

    <div class="step slide" data-x="1000" data-y="3000" data-scale="2">
      over(parent,complement) is function application
    </div>

    <div class="step slide" data-x="3000" data-y="3000" data-scale="2">
      a complex example
    </div>

    <div id="overview" class="step" data-x="1000" data-y="500" data-scale="10">
      <!-- zoom out to show all slides -->
      
    </div>

</div>

<div class="hint">
    <p>Use a spacebar or arrow keys to navigate</p>
</div>
<script>
if ("ontouchstart" in document.documentElement) { 
    document.querySelector(".hint").innerHTML = "<p>Tap on the left or right to navigate</p>";
}
</script>
<script src="js/impress.js"></script>
<script>impress().init();</script>

<script src="js/d3.v3.min.js"></script>       
<script src="js/dagre-d3.min.js"></script>
<script src="js/graphlib-dot.js"></script>
<script src="js/graphs.js"></script>
<script>
  d3.select("#she_sees_the_cat").call(dagreD3.render(), graphlibDot.read(she_sees_the_cat));
  d3.select("#depth_first_1").call(dagreD3.render(),    graphlibDot.read(depth_first_1));
  d3.select("#depth_first_2").call(dagreD3.render(),    graphlibDot.read(depth_first_2));
  d3.select("#depth_first_3").call(dagreD3.render(),    graphlibDot.read(depth_first_3));
  d3.select("#depth_first_4").call(dagreD3.render(),    graphlibDot.read(depth_first_4));
  d3.select("#depth_first_5").call(dagreD3.render(),    graphlibDot.read(depth_first_5));
  d3.select("#depth_first_6").call(dagreD3.render(),    graphlibDot.read(depth_first_6));
  d3.select("#depth_first_7").call(dagreD3.render(),    graphlibDot.read(depth_first_7));
  d3.select("#depth_first_8").call(dagreD3.render(),    graphlibDot.read(depth_first_8));

</script>



</body>
</html>

